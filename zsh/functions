# Functions
TEST_RED="\033[31;01m"
TEST_GREEN="\033[32;01m"
TEST_YELLOW="\033[33;01m"
TEST_BLUE="\033[34;01m"
TEST_NEUTRAL="\033[0m"

##############################
# My Print
# $1: level
# levels:
#   - 1: blue
#   - 2: green
#   - 3: yellow
#   - 4: red
##############################
function my_print()
{
  level=$1
  if [ -z "$1" ]; then
    level='1'
  fi
  shift

  if   [ $level -eq 1 ]; then
    echo -e "${TEST_BLUE}$@${TEST_NEUTRAL}"
  elif [ $level -eq 2 ]; then
    echo -e "${TEST_GREEN}$@${TEST_NEUTRAL}" | sed -e 's/^/  /'
  elif [ $level -eq 3 ]; then
    echo -e "${TEST_YELLOW}$@${TEST_NEUTRAL}" | sed -e 's/^/    /'
  elif [ $level -eq 4 ]; then
    echo -e "${TEST_RED}$@${TEST_NEUTRAL}" | sed -e 's/^/      /'
  fi
}

##############################
# Auto Source
##############################
function auto_source()
{
  cd ~/conf
  br=$(git symbolic-ref HEAD || git-name-rev --name-only HEAD 2>/dev/null)
  br=${br#refs/heads/}
  cd - > /dev/null 2>&1
  my_print 1 "Sourcing my $br conf."
  source ~/.zshrc
}

##############################
# Git Fetch Merge
# $1: remote
##############################
function git_fetch_merge()
{
  remote="$1"
  current_branch=$BRANCH

  if [ -z "$1" ]; then
    remote='origin'
  fi

  my_print 1 "Fetching $remote ..."
  fetch_output=`git fetch $remote 2>&1 | \grep -- '->' | \grep -vE '^From' | \grep -v 'new tag'`
  my_print 2 "$fetch_output"

  my_print 1 "Merge works ..."
  for br in `echo $fetch_output | \grep 'new branch' | tr -s ' 'Â | cut -d' ' -f5`; do
    my_print 2 "Fetching new branch $br"
    git fetch $remote $br:$br
  done

  for br in `echo $fetch_output | \grep -v 'new branch' | tr -s ' ' | cut -d' ' -f3`; do
    if [ -n "`git branch | grep $br`" ]; then
      my_print 2 "Merging $remote/$br in $br"
      if [ "$br" != "$BRANCH" ]; then
	git checkout $br
      fi
      git merge $remote/$br
    else
      my_print 2 "Fetching new branch $br"
      git fetch $remote $br:$br
    fi
  done

  my_print 1 "Return to $current_branch"
  checkout_output=`git checkout $current_branch 2>&1 | cat`
  my_print 3 "$checkout_output"
}

##############################
# ViM
##############################
function v()
{
  if [ $# -eq 1 -o $# -eq 0 ]; then
    vim $@
  else
    vim -O2 $@
  fi
}

##############################
# Repo
##############################
function rppush ()
{
  repo forall $@ -c 'source ~/.zsh/functions; my_print 1 Pushing $REPO_PROJECT ...; git push $REPO_REMOTE $REPO_RREV:$REPO_RREV'
}

function rpfetch ()
{
  nb=$#
  projects=""
  remote=""
  while [ $nb -gt 0 ]; do
    if [ "$1" = "--remote" -o "$1" = "-r" ]; then
      shift
	remote=$1
	nb=$(( $nb - 1 ))
    else
      projects="$projects $1"
    fi
    shift
    nb=$(( $nb - 1 ))
  done

  if [ ! -z "$remote" ]; then
    repo forall $projects -c "source ~/.zsh/functions; my_print 1 Fetching \$REPO_PROJECT ...; git fetch $remote"
  else
    repo forall $projects -c 'source ~/.zsh/functions; my_print 1 Fetching $REPO_PROJECT ...; git fetch $REPO_REMOTE'
  fi
}

function rpmerge ()
{
  nb=$#
  projects=""
  remote=""
  while [ $nb -gt 0 ]; do
    if [ "$1" = "--remote" -o "$1" = "-r" ]; then
      shift
	remote=$1
	nb=$(( $nb - 1 ))
    else
      projects="$projects $1"
    fi
    shift
    nb=$(( $nb - 1 ))
  done

  echo $projects

  if [ ! -z "$remote" ]; then
    repo forall $projects -c "source ~/.zsh/functions; my_print 1 Merging \$REPO_PROJECT ...; git merge $remote/\$REPO_RREV"
  else
    repo forall $projects -c 'source ~/.zsh/functions; my_print 1 Merging $REPO_PROJECT ...; git merge $REPO_REMOTE/$REPO_RREV'
  fi
}

function rpinitbr ()
{
  repo forall $@ -c 'git checkout -b $REPO_RREV $REPO_REMOTE/$REPO_RREV --track'
}

function rpst ()
{
  repo status $@
}

##############################
# Bookmarks
##############################
if [ -z "$bmlist" ]; then
  bmlist=""
fi

function bm ()
{
  export $1="`pwd`"
  bmlist=`for i in $bmlist $1; do echo $i; done | sort -u`
  export bmlist
}

function brm ()
{
  for j in $@; do
    export $j=
    bmlist=`for i in $bmlist; do if [ $i != $j ]; then echo $i; fi; done | sort -u`
  done
  export bmlist
}

function bl ()
{
  for i in $bmlist; do
    local p="echo \$${i}"
    local dir=`eval $p`
    if [ -x $dir ]; then
      echo "	${TEST_GREEN}$i${TEST_NEUTRAL}#-->#${TEST_BLUE}`eval $p`${TEST_NEUTRAL}"
    else
      echo "	${TEST_GREEN}$i${TEST_NEUTRAL}#-->#${TEST_RED}`eval $p`${TEST_NEUTRAL}"
    fi
  done | column -s \# -t
}

function bclear ()
{
  export bmlist=
}

function b ()
{
  p="echo \$$1"
  if [ -z "`eval $p`" ]; then
    echo unknown bookmark: $1
  else
    cd "`eval $p`"
  fi
}

function _bookmark_completion ()
{
  reply=(`echo $bmlist | sed -re 's/ $//'`)
}

# vim:filetype=zsh
