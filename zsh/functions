# Functions
TEST_RED="\033[31;01m"
TEST_GREEN="\033[32;01m"
TEST_YELLOW="\033[33;01m"
TEST_BLUE="\033[34;01m"
TEST_NEUTRAL="\033[0m"

#
# $1: level
# levels:
#   - 1: blue
#   - 2: green
#   - 3: yellow
#   - 4: red
#
my_print()
{
  level=$1
  if [ -z "$1" ]; then
    level='1'
  fi
  shift

  if   [ $level -eq 1 ]; then
    echo -e "${TEST_BLUE}$@${TEST_NEUTRAL}"
  elif [ $level -eq 2 ]; then
    echo -e "${TEST_GREEN}$@${TEST_NEUTRAL}" | sed -e 's/^/  /'
  elif [ $level -eq 3 ]; then
    echo -e "${TEST_YELLOW}$@${TEST_NEUTRAL}" | sed -e 's/^/    /'
  elif [ $level -eq 4 ]; then
    echo -e "${TEST_RED}$@${TEST_NEUTRAL}" | sed -e 's/^/      /'
  fi
}

#
# auto source
#
auto_source()
{
  cd ~/conf
  br=$(git symbolic-ref HEAD || git-name-rev --name-only HEAD 2>/dev/null)
  br=${br#refs/heads/}
  cd - > /dev/null 2>&1
  my_print 1 "Sourcing my $br conf."
  source ~/.zshrc
}

#
# $1: remote
#
git_fetch_merge()
{
  remote="$1"
  current_branch=$BRANCH

  if [ -z "$1" ]; then
    remote='origin'
  fi

  my_print 1 "Fetching $remote ..."
  fetch_output=`git fetch $remote 2>&1 | \grep -- '->' | \grep -vE '^From' | \grep -v 'new tag'`
  my_print 2 "$fetch_output"

  my_print 1 "Merge works ..."
  for br in `echo $fetch_output | \grep 'new branch' | tr -s ' 'Â | cut -d' ' -f5`; do
    my_print 2 "Fetching new branch $br"
    git fetch $remote $br:$br
  done

  for br in `echo $fetch_output | \grep -v 'new branch' | tr -s ' ' | cut -d' ' -f3`; do
    if [ -n "`git branch | grep $br`" ]; then
      my_print 2 "Merging $remote/$br in $br"
      if [ "$br" != "$BRANCH" ]; then
	git checkout $br
      fi
      git merge $remote/$br
    else
      my_print 2 "Fetching new branch $br"
      git fetch $remote $br:$br
    fi
  done

  my_print 1 "Return to $current_branch"
  checkout_output=`git checkout $current_branch 2>&1 | cat`
  my_print 3 "$checkout_output"
}

v()
{
  if [ $# -eq 1 -o $# -eq 0 ]; then
    vim $@
  else
    vim -O2 $@
  fi
}

rppush ()
{
	repo forall $@ -c 'git push $REPO_REMOTE $REPO_RREV:$REPO_RREV'
}
rpfetch ()
{
	nb=$#
	projects=""
	remote=""
	while [ $nb -gt 0 ]; do
		if [ "$1" = "--remote" -o "$1" = "-r" ]; then
			shift
			remote=$1
			nb=$(( $nb - 1 ))
		else
			projects="$projects $1"
		fi
		shift
		nb=$(( $nb - 1 ))
	done

	if [ ! -z "$remote" ]; then
		repo forall $projects -c "git fetch $remote"
	else
		repo forall $projects -c 'git fetch $REPO_REMOTE'
	fi
}

rpmerge ()
{
	repo forall $@ -c 'git merge $REPO_REMOTE/$REPO_RREV'
}
rpinitbr ()
{
	repo forall $@ -c 'git checkout -b $REPO_RREV $REPO_REMOTE/$REPO_RREV --track'
}

# vim:filetype=sh
